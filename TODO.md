
TODO:


[ ] go back to params name `path` instead of `repo` ?
[ ] cleanup commit history
[ ] remove NOTEBOOK from git or sanitize it
[ ] issue first PR


[ ] prepare to open source it :-)
[ ] cleanup some more the dockerfile
[ ] in README explain that there is no public docker image
[ ] completely paramterize the pipeline, to be used also outside pix4d
[ ] Add fake version for github tests, using httptest.NewServer as in hmsg
[ ] Add fake version for resource tests, using httptest.NewServer as in hmsg
[ ] Find a way to run also the E2E tests in the Docker build
[ ] How do I test this thing ???? How do I pass the fake server to Out() ??? Need to wrap in two levels or to make the code read an env var :-( or to always run the real test (no fake). I can pass the server via the "source" map. But fro security (avoid exfiltrating the token) I don't accept the server, I accept a flag like test_api_server boolean. If set, the api server will be hardcoded to "localhost" ?
[ ] is there a newline or not in the gitref, when a tag is present?
[ ] adding the go ldflags to the dockerfile as I did is wrong; now I rebuild way too often because docker detects that variables such as build time or commit hash have changed and decides to reinstall the packages!!! Fix this.

[ ] rename package resource to package cogito !!!
[ ] move packages below pkg/
[ ] add screenshots to the README to explain what is the context, the target_url and the description.
[ ] package github: provide custom user agent (required by GH)
[ ]	How to parse .git/ref (created by the git resource) when it contains also a tag?
    .git/ref: Version reference detected and checked out. It will usually contain the commit SHA
    ref, but also the detected tag name when using tag_filter.

[ ] Probably I should not log.Error() and then return the error; I should just return the error and let the caller issue the log? The problem is that the called is the boilerplate generated by ofcourse. On the other hand, any error terminates the execution, and I always see twice the error messages, so I think that the boilerplate already does the right thing: log error and exit.

[ ] investigate if this is a bug in path.Join() and open ticket if yes
	  // it adds a 3rd slash "/": Post https:///api.github.c ...
	  // API: POST /repos/:owner/:repo/statuses/:sha
    // try also with and without the beginning / for "repos"
	  url := path.Join(s.server, "repos", s.owner, s.repo, "statuses", sha)

[ ] package resource: add more tests for TestIn
[ ] package resource: add more tests for TestCheck

[ ] package resource: is there something cleaner than this "struct{}{}" thing ?
	mandatorySources = map[string]struct{}{
		"owner_repo":   struct{}{},
		"access_token": struct{}{},


[ ] package resource: TestPut:
	find a way to test missing repo dir due to `input:` pipeline misconfiguration
[ ] package resource: TestPut:
	find a way to test mismatch between input: and repo:

[ ] package github: is it possible to return information about current rate limiting, to aid
    in throubleshooting?
[ ] package github: is it possible to detect abuse rate limiting and report it, to help throubleshooting? On the other hand, this is already visible in the error message ...

[ ] extract the userid from the commit :-D and make it available optionally
[ ] add test TestGitHubStatusFake
  Use the http.testing API
  func TestGitHubStatusFake(t *testing.T) {
  	fakeAPI := "http://localhost:8888"
  	repoStatus := github.NewStatus(fakeAPI, ...)
  }
 
[ ] add to TestGitHubStatusE2E(t *testing.T)
  Query the API to validate that the status has been added! But to do this, I need a unique text in the description, maybe I can just store the timestamp or generate an UUID and keep it in memory?

[ ] replace all our usages of the other resources with this one

[ ] Currently we validate that state is one of the valid values in the resource itself.
  Decide what do to among the following:
  - leave it there
  - move it to the github package
  - remove it completely, since GitHub will validate in any case
  Rationale:
  - since the final validation is done anycase in GitHub, what is the point of adding more code to have in any case a partial validation?
  - not validating allows to stay open: if tomorrow github adds another valid state, the resoulce will still work and support the new state withouh requiring a change (yes, not very probable, but still the reasoning make sense, no?)

[ ] githubstatus.NewStatus
    Decide if we do validation now or if we wait until a method is called.
    Having early validation is nice; on the other hand it would impact rate limiting by consuming
    one additional API request, so maybe it is not a wise idea.
